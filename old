// Package layout contains various functions for layint out text.
package layout

import (
	"fmt"
	"regexp"
	"strings"
	"unicode"
)

const (
	// DefaultParagraphSeparator is the sequence that separates paragraphs.
	DefaultParagraphSeparator = "\n\n"
)

var spaceCollapser = regexp.MustCompile(" +")

// WrapOptions affects how wrapping operations behave the text.
type WrapOptions struct {
	// The sequence that separates two paragraphs. This will be preserved if
	// PreserveParagraphs is set to true. If not set or set to the zero-value,
	// this will default to DefaultParagraphSeparator.
	ParagraphSeparator string

	// PreserveParagraphs states whether paragraph separator sequences are
	// preserved. A paragraph separator is defined as two newlines in a row
	// ("\n\n"). If this is set to true, all paragraph separators will be
	// preserved.
	PreserveParagraphs bool

	// Prefix will be added to the beginning of every produced line.
	Prefix string

	// Suffix will be added to the end of every produced line.
	Suffix string

	// ParagraphPrefix will be added to the beginning of every resulting
	// paragraph. If PreserveParagraphs is false, this will always be exactly
	// once.
	ParagraphPrefix string

	// ParagraphSuffix will be added to the end of every resulting
	// paragraph. If PreserveParagraphs is false, this will always be exactly
	// once.
	ParagraphSuffix string
}

// returns a WrapOptions identical to the one it is called on with the exception
// of zero-value options being set to their default.
func (wo WrapOptions) withZeroValuesSetToDefaults() WrapOptions {
	if wo.ParagraphSeparator == "" {
		wo.ParagraphSeparator = DefaultParagraphSeparator
	}
	return wo
}

// Wrap wraps the given text to some width. All runs of whitespace are
// normalized to a single space before wrapping, unless PreserveParagraphs is
// set to true in the options, in which case paragraph separators will not be
// collapsed.
//
// Suffix and Prefix specified in the options will not be added to lines created
// by the paragraph separator if PreserveParagraphs is set to true in
// WrapOptions.
//
// This function will not attempt to wrap text to a width of less than 2. 2 is
// the absolutely minimum and is possible only when there is no prefix/suffix set
// in options. Any value for width that results in a value less than 2 after
// including the length of optional affixes will be automatically reinterpreted
// such that the result is at least 2.
func Wrap(text string, width int, options *WrapOptions) []string {
	var optionsVal WrapOptions
	if options != nil {
		optionsVal = *options
	}

	lines := wrapWithOptions(text, width, optionsVal)

	return lines
}

// DefinitionsTable creates a table that gives two-columns; one for words on
// the left and the other for definitions on the right.
func DefinitionsTable(definitions [][2]string, width int) string {
	const (
		termLeftTabWidth = 2
		minBetween       = 2
		definitionStart  = "- "
	)

	// first find the longest term
	longestTermLen := -1
	for _, t := range definitions {
		strLen := len([]rune(t[0]))
		if strLen > longestTermLen {
			longestTermLen = strLen
		}
	}

	leftWidth := longestTermLen + termLeftTabWidth
	rightWidth := width - leftWidth - minBetween

	lines := []string{}

	for _, item := range definitions {
		term := item[0]
		def := item[1]
		rightPadding := ""
		if len([]rune(term)) < longestTermLen {
			rightPadding = strings.Repeat(" ", longestTermLen-len([]rune(term)))
		}
		leftTab := strings.Repeat(" ", termLeftTabWidth)
		leftCol := []string{fmt.Sprintf("%s%s%s", leftTab, term, rightPadding)}
		rightCol := Wrap(def, rightWidth, &WrapOptions{Prefix: "  "})
		rightCol[0] = "- " + strings.TrimPrefix(rightCol[0], "  ")
		combined := CombineColumnsBlock(leftCol, rightCol, minBetween)
		lines = append(lines, combined...)
		lines = append(lines, "")
	}

	if len(lines) > 0 {
		lines = lines[:len(lines)-1] // remove trailing newline
	}

	return strings.Join(lines, "\n")
}

// CollapseSpace converts all runs of white space characters to a single space.
func CollapseSpace(text string) string {
	textRunes := []rune(text)
	for i := 0; i < len(textRunes); i++ {
		if unicode.IsSpace(textRunes[i]) {
			textRunes[i] = ' ' // set it to actual space char
		}
	}
	text = string(textRunes)
	text = spaceCollapser.ReplaceAllString(text, " ")
	text = strings.TrimSpace(text)
	return text
}

// CombineColumns takes two seperate text sequences and puts them into two
// columns. Each column will be properly wrapped to fit.
//
// This function will attempt to align the columns such that the returned text
// is widthTarget large at its widest point. If the left and right columns
// cannot be wrapped such that widthTarget is achieved (for instance due to
// widthTarget being smaller than the line with longest combined length of the
// two columns plus minSpaceBetween), the lowest possible integer greater than
// widthTarget will be used.
//
// The columns will be wrapped such that the the left column will take up
// leftColPercent of the available layout area (width - space between), and the
// right column will take up the rest. If leftColPercent is less than 0.0, it
// will be assumed to be 0.0. If greater than 1.0, it will be assumed to be 1.0.
// The minimum width that a column can be is always 2 characters wide.
//
// Returns the columns and the actual maxWidth of the returned block. If both
// columns are empty, width will be 0.
func CombineColumns(leftText string, rightText string, minSpaceBetween int, widthTarget int, leftColPercent float64, options *WrapOptions) (combined string, width int) {
	if leftText == "" && rightText == "" {
		return "", 0
	}

	if leftColPercent <= 0.0 {
		leftColPercent = 0.0
	}
	if leftColPercent > 1.0 {
		leftColPercent = 1.0
	}

	// it unreasonable to wrap each column to anything less than 2;
	// need at least 1 char for the next in a word and 1 for a continuation dash.
	// In addition, there must be enough space for the minSpaceBetween, so maxWidthTarget
	// must be at least the sum of these lengths otherwise we cannot respect it.
	width = widthTarget
	minLeftColWidth := 2
	minRightColWidth := 2
	minWidth := minSpaceBetween + minLeftColWidth + minRightColWidth
	if widthTarget < minWidth {
		width = minWidth
	}

	leftColWidth := int(float64(width-minSpaceBetween) * leftColPercent)
	if leftColWidth < minLeftColWidth {
		leftColWidth = minLeftColWidth
	}
	// make sure there is still space for right col
	if (width-minSpaceBetween)-leftColWidth < minRightColWidth {
		minLeftColWidth = (width - minSpaceBetween) - minRightColWidth
	}

	// difference instead of /2 here in case leftColWidth had int truncation
	// happen during its calculation.
	rightColWidth := (width - minSpaceBetween) - leftColWidth
	if rightColWidth < minRightColWidth {
		// should never happen since minWidths are used to calc max width
		panic("rightColWidth < minRightColWidth even though it should have been accounted for in call to CombineColumns")
	}

	leftColBlock := Wrap(leftText, leftColWidth, options)
	rightColBlock := Wrap(rightText, rightColWidth, options)

	combinedBlock := CombineColumnsBlock(leftColBlock, rightColBlock, minSpaceBetween)
	return strings.Join(combinedBlock, "\n"), width
}

// CombineColumnsBlock takes two separate columns and combines them into a
// single block of text. The right column will be left-aligned such that it will
// be separated by minSpaceBetween space characters at minimum from the left
// column.
//
// The left and right column blocks do not need to be the same length; if one
// has more lines than the other, the returned block will have a number of lines
// equal to the greater number of lines between leftText and rightText. A nil
// slice is considered equivalent to a column of line length 0.
func CombineColumnsBlock(leftText []string, rightText []string, minSpaceBetween int) []string {
	if len(leftText) == 0 && len(rightText) == 0 {
		return []string{}
	}
	numLines := len(leftText)
	if numLines < len(rightText) {
		numLines = len(rightText)
	}

	// to find how far the right column should be shifted, we need to find the
	// maximum width of the left column
	var leftColMaxWidth int
	for _, line := range leftText {
		lineLen := len([]rune(line))
		if lineLen > leftColMaxWidth {
			leftColMaxWidth = lineLen
		}
	}

	totalCharsOnLeft := leftColMaxWidth + minSpaceBetween

	combined := make([]string, numLines)
	for i := 0; i < numLines; i++ {
		// first get lines from each column
		var leftLine string
		var leftLineCharCount int
		var rightLine string
		if i < len(leftText) {
			leftLine = leftText[i]
			leftLineCharCount = len([]rune(leftLine))
		}
		if i < len(rightText) {
			rightLine = rightText[i]
		}

		charsToAddToLeft := totalCharsOnLeft - leftLineCharCount
		midSpacer := strings.Repeat(" ", charsToAddToLeft)

		combined[i] = fmt.Sprintf("%s%s%s", leftLine, midSpacer, rightLine)
	}

	return combined
}

/*
	block := Wrap(text, 20)
	margined := AddLeftMarginBlock(block)
*/

// Pluralize returns the plural form of the word unless the number is exactly 1, in which case it will return
// the singular form.
func Pluralize(count int, singular string, plural string) string {
	if count == 1 {
		return singular
	}
	return plural
}

// CountOf returns the number followed by either the singular or plural depending on the number.
func CountOf(count int, singular string, plural string) string {
	return fmt.Sprintf("%d %s", count, Pluralize(count, singular, plural))
}

// AddRightMargin adds a margin consisting of the space character repeated width
// times to the left side of the provided lines. The text is split into lines by
// any newline characters it contains and then passed to AddRightMarginBlock.
func AddRightMargin(text string, width int) string {
	lines := strings.Split(text, "\n")
	marginedLines := AddRightMarginBlock(lines, width)
	return strings.Join(marginedLines, "\n")
}

// AddLeftMargin adds a margin consisting of the space character repeated width
// times to the left side of the provided lines. The text is split into lines by
// any newline characters it contains and then passed to AddLeftMarginBlock.
func AddLeftMargin(text string, width int) string {
	lines := strings.Split(text, "\n")
	marginedLines := AddLeftMarginBlock(lines, width)
	return strings.Join(marginedLines, "\n")
}

// AddLeftMarginBlock adds a margin consisting of the space character
// repeated width times to the left side of the provided lines.
func AddLeftMarginBlock(text []string, width int) []string {
	modifiedBlock := make([]string, len(text))
	marginStr := strings.Repeat(string([]rune{' '}), width)
	for idx, line := range text {
		modifiedBlock[idx] = fmt.Sprintf("%s%s", marginStr, line)
	}
	return modifiedBlock
}

// AddRightMarginBlock adds a margin consisting of the space character
// repeated width times to the right side of the provided lines.
func AddRightMarginBlock(text []string, width int) []string {
	modifiedBlock := make([]string, len(text))
	marginStr := strings.Repeat(string([]rune{' '}), width)
	for idx, line := range text {
		modifiedBlock[idx] = fmt.Sprintf("%s%s", line, marginStr)
	}
	return modifiedBlock
}

// Justify returns a string consisting of the provided text with each line
// justified to the given width. The text is split into lines by any newline
// characters it contains and then passed to JustifyBlock.
func Justify(text string, width int) string {
	lines := strings.Split(text, "\n")
	justifiedLines := JustifyBlock(lines, width)
	return strings.Join(justifiedLines, "\n")
}

// JustifyBlock runs a justify on every line except for the last.
func JustifyBlock(text []string, width int) []string {
	justified := make([]string, len(text))
	for idx, line := range text {
		if idx+1 < len(text) {
			justified[idx] = JustifyLine(line, width)
		}
	}
	justified[len(text)-1] = text[len(text)-1]
	return justified
}

// JustifyLine takes the given text and attempts to justify it. No attempt is
// made to split the given line into multiple lines.
//
// If there are no spaces in the given string, it is returned centered.
// If it is longer than the desired width after collapsing spaces in it, the
// collapsed-space string is returned without further modification.
func JustifyLine(text string, width int) string {
	// CollapseSpace in a line so that it can be properly laid out
	text = CollapseSpace(text)

	textRunes := []rune(text)
	curLength := len([]rune(textRunes))
	if curLength >= width {
		return text
	}

	splitWords := strings.Split(text, " ")
	numGaps := len(splitWords) - 1
	if numGaps < 1 {
		return text
	}
	fullList := []string{}
	for idx, word := range splitWords {
		fullList = append(fullList, word)
		if idx+1 < len(splitWords) {
			fullList = append(fullList, " ")
		}
	}

	spacesToAdd := width - curLength
	spaceIdx := 0
	fromRight := false
	oddSubtractor := 1
	if numGaps%2 == 0 {
		oddSubtractor = 0
	}
	for i := 0; i < spacesToAdd; i++ {
		spaceWordIdx := (spaceIdx * 2) + 1
		if fromRight {
			spaceWordIdx = (((numGaps - oddSubtractor) - spaceIdx) * 2) + 1
		}
		fullList[spaceWordIdx] = fullList[spaceWordIdx] + " "
		fromRight = !fromRight
		spaceIdx++
		if spaceIdx >= numGaps {
			spaceIdx = 0
		}
	}

	finishedWord := strings.Join(fullList, "")
	return finishedWord
}

func appendWordToLine(lines []string, curWord []rune, curLine []rune, width int) (newLines []string, newCurLine []rune) {
	// any width less than 2 is not possible and will result in an infinite loop,
	// as at least one character is required for next in word, and one character for
	// line continuation.
	if width < 2 {
		panic(fmt.Sprintf("invalid width in call to appendWordToLine: %v", width))
	}
	//originalWord := string(curWord)
	for len(curWord) > 0 {
		addedChars := len(curWord)
		if len(curLine) != 0 {
			addedChars++ // for the space
		}
		if len(curLine)+addedChars == width {
			if len(curLine) != 0 {
				curLine = append(curLine, ' ')
			}
			curLine = append(curLine, curWord...)
			lines = append(lines, string(curLine))
			curLine = []rune{}
			curWord = []rune{}
		} else if len(curLine)+addedChars > width {
			if len(curLine) == 0 {
				curLine = append([]rune{}, curWord[0:width-1]...)
				curLine = append(curLine, '-')
				curWord = curWord[width-1:]
			}
			lines = append(lines, string(curLine))
			curLine = []rune{}
		} else {
			if len(curLine) != 0 {
				curLine = append(curLine, ' ')
			}
			curLine = append(curLine, curWord...)
			curWord = []rune{}
		}
	}
	return lines, curLine
}

// addRightMarginCharTextBlock adds a margin consisting of the provided character
// repeated width times to the left side of the provided lines.
func addRightMarginCharBlock(textBlockLines []string, width int, ch rune) []string {
	modifiedBlock := make([]string, len(textBlockLines))
	marginStr := strings.Repeat(string([]rune{ch}), width)
	for idx, line := range textBlockLines {
		modifiedBlock[idx] = fmt.Sprintf("%s%s", line, marginStr)
	}
	return modifiedBlock
}

// does a wrap without considering any additional lengths. Automatically
// normalizes all runs of space characters to a single space.
func doPrecalculatedWidthWrap(text string, width int) []string {
	if width < 2 {
		panic(fmt.Sprintf("invalid width: %v", width))
	}

	// normalize string to convert all whitespace to single space char.
	text = CollapseSpace(text)
	if text == "" {
		return []string{""}
	}

	var lines []string
	toConsume := []rune(text)
	curWord := []rune{}
	curLine := []rune{}
	for i := 0; i < len(toConsume); i++ {
		ch := toConsume[i]
		if ch == ' ' {
			lines, curLine = appendWordToLine(lines, curWord, curLine, width)
			curWord = []rune{}
		} else {
			curWord = append(curWord, ch)
		}
	}

	if len(curWord) != 0 {
		lines, curLine = appendWordToLine(lines, curWord, curLine, width)
		curWord = []rune{}
	}

	if len(curLine) != 0 {
		lines = append(lines, string(curLine))
	}

	return lines
}

func splitParaSepIntoParts(paraSep string) (prevLineSuffix string, lines []string, nextLinePrefix string) {
	parts := strings.Split(paraSep, "\n")
	if len(parts) == 1 {
		return parts[0], []string{}, ""
	}
	return parts[0], parts[1 : len(parts)-1], parts[len(parts)-1]
}

func wrapWithOptions(text string, width int, options WrapOptions) []string {
	options = options.withZeroValuesSetToDefaults()
	prefixLen := len([]rune(options.Prefix))
	suffixLen := len([]rune(options.Suffix))
	widthWithoutAffixes := width - prefixLen - suffixLen
	if widthWithoutAffixes < 2 {
		widthWithoutAffixes = 2
	}

	paraSepPrevSuffix, paraSepLines, paraSepNextPrefix := splitParaSepIntoParts(options.ParagraphSeparator)

	var totalLines int
	var wrappedParagraphs [][]string
	if options.PreserveParagraphs {
		var paragraphs = strings.Split(text, options.ParagraphSeparator)
		wrappedParagraphs = make([][]string, len(paragraphs))
		for idx, para := range paragraphs {
			trimParaSuffix := false
			trimParaPrefix := false
			// to get proper width, make sure we add the prefix and suffix to the para
			if idx > 0 {
				// if there are prev paragraphs, add the next line prefix
				para = paraSepNextPrefix + para
				trimParaPrefix = true
			}
			if idx+1 < len(paragraphs) {
				// if there are more paragraphs, add the prev line suffix
				para += paraSepPrevSuffix
				trimParaSuffix = true

				// update totalLines to include the "between paragraphs" lines added by the separator.
				totalLines += len(paraSepLines)
			}

			para = options.ParagraphPrefix + para + options.ParagraphSuffix
			wrappedPara := doPrecalculatedWidthWrap(para, widthWithoutAffixes)
			// trim off paragraph prefixes and suffixes to let the later routine add them outside of the
			// prefix/suffix specified in options (if any)
			wrappedPara[0] = strings.TrimPrefix(wrappedPara[0], options.ParagraphPrefix)
			wrappedPara[len(wrappedPara)-1] = strings.TrimSuffix(wrappedPara[len(wrappedPara)-1], options.ParagraphPrefix)
			totalLines += len(wrappedPara)

			// trim off para break prefixes and suffixes to let the later routine add them outside of the
			// prefix/suffix specified in options (if any)
			if trimParaPrefix {
				wrappedPara[0] = strings.TrimPrefix(wrappedPara[0], paraSepNextPrefix)
			}
			if trimParaSuffix {
				wrappedPara[len(wrappedPara)-1] = strings.TrimSuffix(wrappedPara[len(wrappedPara)-1], paraSepPrevSuffix)
			}
			wrappedParagraphs[idx] = wrappedPara
		}
	} else {
		para := options.ParagraphPrefix + text + options.ParagraphSuffix
		wrapped := doPrecalculatedWidthWrap(para, widthWithoutAffixes)
		// trim off paragraph prefixes and suffixes to let the later routine add them outside of the
		// prefix/suffix specified in options (if any)
		wrapped[0] = strings.TrimPrefix(wrapped[0], options.ParagraphPrefix)
		wrapped[len(wrapped)-1] = strings.TrimSuffix(wrapped[len(wrapped)-1], options.ParagraphPrefix)
		totalLines = len(wrapped)
		wrappedParagraphs = [][]string{wrapped}
	}

	// add affixes and paragraph breaks to the lines
	lines := make([]string, totalLines)
	curParaLines := lines
	for paraIdx, para := range wrappedParagraphs {
		for lineIdx := range para {
			curParaLines[lineIdx] = fmt.Sprintf("%s%s%s", options.Prefix, para[lineIdx], options.Suffix)

			if lineIdx == 0 {
				// if on the first line of the paragraph, add the paragraph prefix
				curParaLines[lineIdx] = options.ParagraphPrefix + curParaLines[lineIdx]

				// if on the first line of any paragraph after the first, add the separator prefix to it
				if paraIdx > 0 {
					curParaLines[lineIdx] = paraSepNextPrefix + curParaLines[lineIdx]
				}
			}

			if lineIdx+1 >= len(para) {
				// insert paragraph suffix after last line
				curParaLines[lineIdx] = curParaLines[lineIdx] + options.ParagraphSuffix
			}
		}
		extraLines := 0
		if paraIdx+1 < len(wrappedParagraphs) {
			curParaLines[len(para)-1] = curParaLines[len(para)-1] + paraSepPrevSuffix

			for paraSepIdx, paraSepLine := range paraSepLines {
				curParaLines[len(para)+paraSepIdx] = paraSepLine
			}
			extraLines += len(paraSepLines)
		}

		// set destination lines to refer to the end of where we have written
		// for next loop
		curParaLines = curParaLines[len(para)+extraLines:]
	}

	return lines
}
